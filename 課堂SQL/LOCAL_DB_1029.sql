
-- SQL UNION 聯集(不包含重覆值)
-- 1.查詢欄位個數必須相同
-- 2.查詢欄位型別必須相同(MySQL無此限制)
-- 1,2,NULL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
UNION
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;
-- 結果：NULL,1,2,3

-- MySQL FULL JOIN 替代方案使用 UNION 將 LEFT JOIN + RIGHT JOIN
SELECT G.GEOGRAPHY_ID, G.REGION_NAME, S.STORE_ID, S.STORE_NAME
FROM GEOGRAPHY G 
LEFT JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
UNION
SELECT G.GEOGRAPHY_ID, G.REGION_NAME, S.STORE_ID, S.STORE_NAME
FROM GEOGRAPHY G 
RIGHT JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


--   SQL UNION ALL 聯集(包含重覆值)
-- 1,2,NULL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
UNION ALL
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;


--   SQL INTERSECT 交集(不包含重覆值)(MySQL不支援)
-- 1,2,NULL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
INTERSECT
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;
-- 結果：1,2


--   SQL INTERSECT 交集(MySQL替代寫法)
SELECT DISTINCT G.GEOGRAPHY_ID 
FROM GEOGRAPHY G
JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


-- SQL MINUS 排除(不包含重覆值) (MySQL不支援)
-- Oracle MINUS
-- 1,2,NULL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
MINUS
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;
-- 結果：NULL

-- MS SQL:EXCEPT
-- 1,2,NULL
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
EXCEPT
-- 1,2,3
SELECT GEOGRAPHY_ID FROM GEOGRAPHY;

-- SQL MINUS 排除(MySQL替代寫法)
-- LEFT JOIN + table2.id IS NULL = MINUS

SELECT S.GEOGRAPHY_ID, G.GEOGRAPHY_ID
FROM STORE_INFORMATION S
LEFT JOIN GEOGRAPHY G ON S.GEOGRAPHY_ID  = G.GEOGRAPHY_ID 
WHERE G.GEOGRAPHY_ID IS NULL;

-- G:1,2,3
-- MINUS
-- S:1,2,NULL
SELECT G.GEOGRAPHY_ID, S.GEOGRAPHY_ID
FROM GEOGRAPHY G
LEFT JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
WHERE S.GEOGRAPHY_ID IS NULL;


--   SQL SubQuery 子查詢
-- "最高營業額"的"商店資料"
-- "商店資料"
SELECT * FROM STORE_INFORMATION
WHERE SALES = (
	-- subquery子查詢
	-- "最高營業額"
	SELECT MAX(SALES) FROM STORE_INFORMATION
);

-- 『簡單子查詢』 (Simple Subquery)
-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY WHERE REGION_NAME = 'West'
);


-- 『相關子查詢』(Correlated Subquery)
-- 10,250(扣掉join不到的6號商店營業額)
-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION S
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY G WHERE S.GEOGRAPHY_ID = G.GEOGRAPHY_ID
);

-- 13,250
SELECT SUM(SALES) FROM STORE_INFORMATION;


SELECT G.*, S.*
FROM (
	SELECT * FROM GEOGRAPHY
) G,
(
	SELECT * FROM STORE_INFORMATION
) S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- WITH (Common Table Expressions)
-- 相關子查詢
WITH G AS (
	SELECT * FROM GEOGRAPHY
),
S AS (
	SELECT * FROM STORE_INFORMATION
)
SELECT G.*, S.*
FROM G, S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


WITH G AS (
	SELECT * FROM GEOGRAPHY
),
S AS (
	SELECT G.GEOGRAPHY_ID, G.REGION_NAME, STORE.STORE_ID, STORE.STORE_NAME
    FROM G, STORE_INFORMATION STORE
    WHERE STORE.GEOGRAPHY_ID = G.GEOGRAPHY_ID
)
SELECT * FROM S;


--   SQL EXISTS 存在式關聯查詢
-- EXISTS 是用來測試「內查詢」有沒有產生任何結果。
-- 如果有的話，系統就會執行「外查詢」中的 SQL。
-- 若是沒有的話，那整個 SQL 語句就不會產生任何結果。

-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION
WHERE EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY WHERE REGION_NAME = 'West'
);

-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION S
WHERE EXISTS (
	-- 內查詢
	SELECT * FROM GEOGRAPHY G
    WHERE S.GEOGRAPHY_ID = G.GEOGRAPHY_ID
    AND G.REGION_NAME = 'West'
);

--   SQL CASE WHEN 條件查詢
-- CASE接欄位
SELECT STORE_ID, STORE_NAME, SALES,
	CASE STORE_NAME
		WHEN 'Los Angeles' THEN SALES * 2
        WHEN 'San Diego' THEN SALES * 1.5
        ELSE SALES
	END "NEW_SALES"
FROM STORE_INFORMATION
ORDER BY STORE_NAME;


-- CASE接條件
SELECT STORE_ID, STORE_NAME, SALES,
	CASE 
		WHEN (SALES BETWEEN 0 AND 1000) THEN '0-1000'
        WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001-2000'
        WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001-3000'
        WHEN (SALES > 3000) THEN '> 3000'
        ELSE SALES
	END "SALES_RANGE"
FROM STORE_INFORMATION
ORDER BY SALES;

-- 運用自我連結 (self join)來計算排名
SELECT S1.STORE_ID, S1.STORE_NAME, S1.SALES,  
	S2.STORE_ID, S2.STORE_NAME, S2.SALES
FROM STORE_INFORMATION S1, STORE_INFORMATION S2
WHERE S2.SALES >= S1.SALES
ORDER BY S1.SALES, S2.SALES;


SELECT S1.STORE_ID, S1.STORE_NAME, S1.SALES, COUNT(S2.STORE_ID) "STORE_RANK"
FROM STORE_INFORMATION S1, STORE_INFORMATION S2
WHERE S2.SALES >= S1.SALES
GROUP BY S1.STORE_ID, S1.STORE_NAME, S1.SALES
ORDER BY STORE_RANK;


 -- SQL 排名函數
 -- 全部資料排名
 SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (ORDER BY SALES DESC) "STORE_RANK"
 FROM STORE_INFORMATION; 
 
 -- 資料分群排名(依各區域)
 SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
	RANK() OVER (PARTITION BY GEOGRAPHY_ID  ORDER BY SALES DESC) "STORE_RANK"
 FROM STORE_INFORMATION;
 
 
 -- 資料分群排名(依各商店)
 SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (PARTITION BY STORE_NAME  ORDER BY SALES DESC) "STORE_RANK"
 FROM STORE_INFORMATION;
 
-- Analytic Functions with OVER Clause (分析函數)
-- DENSE_RANK (  )：當有同名次時(排名结果是連續的)
-- PERCENT_RANK (  )：名次所佔的百分比
-- 公式：(RANK(  ) - 1)  /  (總資料列筆數 - 1)
-- ROW_NUMBER (  ) ：依序編號
 SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (ORDER BY SALES DESC) "STORE_RANK",
    DENSE_RANK() OVER (ORDER BY SALES DESC) "STORE_DENSE_RANK",
    PERCENT_RANK() OVER (ORDER BY SALES DESC) "STORE_PERCENT_RANK",
    ROW_NUMBER() OVER (ORDER BY SALES DESC) "STORE_ROW_NUMBER"
 FROM STORE_INFORMATION;
 
 
 -- Aggregate Functions with OVER Clause (聚合函數) 
 SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
     -- 依「區域劃分」取營業額"最小值"
	MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
	-- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
	-- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_SALES,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
	AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES
 FROM STORE_INFORMATION
 ORDER BY GEOGRAPHY_ID, SALES;
 
 
 -- Analytic Functions with OVER Clause (分析函數)
 SELECT STORE_ID, STORE_NAME, SALES,
	-- 依「營業額」排序取"上一個"營業額
    LAG(SALES)OVER(ORDER BY SALES) "PREV_SAELS",
    -- 依「營業額」排序取"下一個"營業額
    LEAD(SALES)OVER(ORDER BY SALES) "NEXT_SAELS"
 FROM STORE_INFORMATION
 ORDER BY SALES;
 
 
 