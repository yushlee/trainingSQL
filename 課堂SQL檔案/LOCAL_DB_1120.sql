-- Ctrl + /

-- SQL UNION 聯集(不包含重覆值)
-- 1.各查詢之間所查詢的欄位"個數"必須一致!
-- 2.各查詢之間所查詢的欄位"型別"必須一致!
-- 1,2,3,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
UNION
-- 1,2,3
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY;

-- MySQL無此限制
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
UNION
-- 1,2,3
SELECT REGION_NAME FROM GEOGRAPHY;


-- SQL UNION ALL 聯集(包含重覆值)
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
UNION ALL
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY;


-- SQL INTERSECT 交集
-- 1,2,3,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION
INTERSECT
-- 1,2,3
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY;


-- MySQL沒有支援INTERSECT(替代方案)
-- https://www.yiibai.com/mysql/sql-union-mysql.html
-- INNER JOIN + DISTINCT = INTERSECT查詢交集結果
SELECT DISTINCT G.GEOGRAPHY_ID 
FROM GEOGRAPHY G
JOIN STORE_INFORMATION S ON G.GEOGRAPHY_ID  = S.GEOGRAPHY_ID;


-- 在 MINUS 指令下，不同的值只會被列出一次。 
-- SQL MINUS 排除(不包含重覆值) 
--  MINUS (Oracle)、EXCEPT (MS SQL)指令是運用在兩個 SQL 語句上
-- 它先找出第一個 SQL 語句所產生的結果，
-- 然後看這些結果「有沒有在第二個 SQL 語句的結果中」。
-- 如果「有」的話，那這一筆資料就被「去除」，而不會在最後的結果中出現。
-- 如果「沒有」的話，那這一筆資料就被「保留」，而就會在最後的結果中出現。


-- 1,2,3
SELECT GEOGRAPHY_ID  FROM GEOGRAPHY
MINUS
-- 1,2,null
SELECT GEOGRAPHY_ID FROM STORE_INFORMATION;
-- 查詢結果:3

-- MySQL沒有支援 MINUS(替代方案)
-- https://www.yiibai.com/mysql/minus.html
-- LEFT JOIN + table2.id IS NULL = MINUS
-- LEFT JOIN - INNER JOIN = MINUS
SELECT G.GEOGRAPHY_ID 
FROM geography G
LEFT JOIN store_information S ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
WHERE S.GEOGRAPHY_ID IS NULL;

-- 查詢"最高營業額"的"商店資料"
-- 外查詢
SELECT * FROM STORE_INFORMATION
WHERE SALES = (
	-- 內查詢
	SELECT MAX(SALES) FROM STORE_INFORMATION
);

-- SQL SubQuery 子查詢
-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM geography WHERE REGION_NAME = 'West'
);


-- 內部查詢本身與外部查詢沒有關係。這一類的子查詢稱為『簡單子查詢』 (Simple Subquery)
-- 部查詢是要利用到外部查詢提到的表格中的欄位，那這個字查詢就被稱為『相關子查詢』(Correlated Subquery)
-- 外查詢
SELECT SUM(SALES) FROM STORE_INFORMATION S 
WHERE GEOGRAPHY_ID IN (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
);

-- 簡單子查詢
-- 查詢與查詢之間彼此獨立不能互相使用對方的欄位
SELECT G.*, S.*
FROM (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
) G,
(
	SELECT  STORE_ID,STORE_NAME, SALES, STORE_DATE, GEOGRAPHY_ID FROM STORE_INFORMATION
)S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


SELECT G.*, S.*
FROM (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
) G JOIN
(
	SELECT  STORE_ID,STORE_NAME, SALES, STORE_DATE, GEOGRAPHY_ID FROM STORE_INFORMATION
)S
ON G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


SELECT G_STORE.*
FROM (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
) G,
(
	SELECT G.GEOGRAPHY_ID, G.REGION_NAME, 
		S.STORE_ID, S.STORE_NAME, S.SALES, S.STORE_DATE
    FROM STORE_INFORMATION S, G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
) G_STORE;



SELECT G.*, S.*
FROM GEOGRAPHY G, STORE_INFORMATION S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;


-- 相關子查詢
WITH G AS (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
), 
S AS (
	SELECT STORE_ID,STORE_NAME, SALES, STORE_DATE, GEOGRAPHY_ID FROM STORE_INFORMATION
)
SELECT G.*, S.*
FROM G, S
WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID;

-- WITH (Common Table Expressions)
-- 子查詢與子查詢之間join查詢，有個支援更為合適的SQL專用語法 WITH  AS，使用SQL子查詢在撰寫更有結構性及閱續性!
-- 且查詢與查詢之間可以相互使用欄位做關聯式查詢
-- PS：注意只能下面的查詢使用上面查詢的欄位
WITH G AS (
	SELECT GEOGRAPHY_ID, REGION_NAME FROM GEOGRAPHY
), 
G_STORE AS (
	SELECT G.GEOGRAPHY_ID, G.REGION_NAME, 
		S.STORE_ID, S.STORE_NAME, S.SALES, S.STORE_DATE
    FROM STORE_INFORMATION S, G
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
)
SELECT * FROM G_STORE;


-- SQL EXISTS 存在式關聯查詢
-- EXISTS 是用來測試「內查詢」有沒有產生任何結果。
-- 如果有的話，系統就會執行「外查詢」中的 SQL。
-- 若是沒有的話，那整個 SQL 語句就不會產生任何結果。
-- 外查詢
SELECT * FROM STORE_INFORMATION 
WHERE EXISTS (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY WHERE REGION_NAME = 'West'
);


-- EXISTS 搭配關聯查詢
-- 外查詢
SELECT * FROM STORE_INFORMATION S
WHERE EXISTS (
	-- 內查詢
	SELECT GEOGRAPHY_ID FROM GEOGRAPHY G 
    WHERE G.GEOGRAPHY_ID = S.GEOGRAPHY_ID
    AND REGION_NAME = 'West'
);


-- SQL CASE WHEN 條件查詢

/*
SELECT CASE ("欄位名") 
  WHEN "條件1" THEN "結果1"
  WHEN "條件2" THEN "結果2"
  ...
  ELSE "結果N" END
  FROM "表格名" 
*/

SELECT STORE_ID, STORE_NAME, SALES,
	CASE STORE_NAME
		WHEN 'Los Angeles' THEN SALES * 2
        WHEN 'San Diego' THEN SALES * 1.5
        ELSE SALES END "NEW_SALES"
FROM STORE_INFORMATION
ORDER BY STORE_NAME;

-- 每一個營業額的所在的數字區間
-- 0 ~ 1000 3
-- 1001 ~ 2000 3
-- 2001 ~ 3000 3
-- > 3000 0
SELECT S.RANGE_SALES, COUNT(S.STORE_ID) 
FROM (
	SELECT STORE_ID, STORE_NAME, SALES,
		CASE 
			WHEN (SALES BETWEEN 0 AND 1000) THEN '0 ~ 1000'
			WHEN (SALES BETWEEN 1001 AND 2000) THEN '1001 ~ 2000'
			WHEN (SALES BETWEEN 2001 AND 3000) THEN '2001 ~ 3000'
			WHEN SALES > 3000 THEN '>3000'
			END "RANGE_SALES"
	FROM STORE_INFORMATION
	ORDER BY SALES
) S 
GROUP BY RANGE_SALES
ORDER BY RANGE_SALES;


SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (ORDER BY SALES DESC) "RANK_STORE"
FROM STORE_INFORMATION;


-- 資料分群排名劃分欄位
SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (PARTITION BY STORE_NAME ORDER BY SALES DESC) "RANK_STORE_GROUP"
FROM STORE_INFORMATION;


SELECT STORE_ID, STORE_NAME, SALES,
	RANK() OVER (ORDER BY SALES DESC) "RANK_STORE",
    DENSE_RANK() OVER (ORDER BY SALES DESC) "DENSE_RANK_STORE",
    PERCENT_RANK () OVER (ORDER BY SALES DESC) "PERCENT_RANK_STORE",
    ROW_NUMBER () OVER (ORDER BY SALES DESC) "ROW_NUMBER_SALES"
FROM STORE_INFORMATION;


SELECT S.* 
FROM (
	SELECT STORE_ID, STORE_NAME, SALES,
		ROW_NUMBER () OVER (ORDER BY SALES DESC) "ROW_NUMBER_SALES"
	FROM STORE_INFORMATION
) S WHERE S.ROW_NUMBER_SALES <= 5;

-- Aggregate Functions with OVER Clause (聚合函數)
SELECT STORE_ID, STORE_NAME, SALES, GEOGRAPHY_ID,
    -- 依「區域劃分」取營業額"最小值"
    MIN(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MIN_SALES,
    -- 依「區域劃分」取營業額"最大值"
    MAX(SALES) OVER (PARTITION BY GEOGRAPHY_ID) MAX_SALES,
    -- 依「區域劃分」取商店"數量"
    COUNT(STORE_ID) OVER (PARTITION BY GEOGRAPHY_ID) COUNT_STORE_ID,
    -- 依「區域劃分」取營業額"總和"
    SUM(SALES) OVER (PARTITION BY GEOGRAPHY_ID) SUM_SALES,
    -- 依「區域劃分」取營業額"平均"
    AVG(SALES) OVER (PARTITION BY GEOGRAPHY_ID) AVG_SALES
FROM STORE_INFORMATION
ORDER BY GEOGRAPHY_ID, SALES;

-- Analytic Functions with OVER Clause (分析函數)
SELECT STORE_ID, STORE_NAME,
    ROW_NUMBER( ) OVER (ORDER BY SALES) ROWNO_STORE,
    SALES,
    -- 依「營業額」排序取"上一個"營業額
    LAG(SALES) OVER (ORDER BY SALES) PREV_SALES,
    -- 依「營業額」排序取"下一個"營業額
    LEAD(SALES) OVER (ORDER BY SALES) NEXT_SALES
FROM STORE_INFORMATION
ORDER BY SALES;



-- Oracle 轉換函數：
-- 1.TO_CHAR(d , format)：日期轉字串
SELECT TO_CHAR(sysdate,'YYYY-mm-DD HH24:MI:SS'),
  -- 2.TO_DATE(string ,format)：字串轉日期
  TO_DATE('2018-05-15 12:30:23','YYYY-mm-DD HH24:MI:SS'),
  -- 3.TO_TIMESTAMP(string,  [format])：字串轉日期
  TO_TIMESTAMP( '2011-12-23 12:30:23.999', 'YYYY-MM-DD HH24:MI:SS.FF3'),
  -- 4.TO_NUMBER(STRING)：字串轉數字
  TO_NUMBER('3') + TO_NUMBER('2')
FROM DUAL;


-- MySQL轉換函數：
-- 1.DATE_FORMAT(date,format):日期轉字串
SELECT DATE_FORMAT(SYSDATE(), '%Y-%m-%d %T'),
-- 2.STR_TO_DATE(str,format):字串轉日期
STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"),
DATE_ADD(STR_TO_DATE('2021-08-15 00:00:00', "%Y-%m-%d %T"), INTERVAL 5 DAY);

SELECT CONVERT(150, CHAR);
SELECT CONVERT('150', UNSIGNED INTEGER);


-- MS SQL
-- 1.日期轉字串
SELECT convert(varchar, getdate(), 100) 'mon dd yyyy hh:mmAM (or PM)';
SELECT convert(varchar, getdate(), 101) 'mm/dd/yyyy';
SELECT convert(varchar, getdate(), 102) 'yyyy.mm.dd';
SELECT convert(varchar, getdate(), 103) 'dd/mm/yyyy';
SELECT convert(varchar, getdate(), 104) 'dd.mm.yyyy';
SELECT convert(varchar, getdate(), 105) 'dd-mm-yyyy';
SELECT convert(varchar, getdate(), 106) 'dd mon yyyy';
SELECT convert(varchar, getdate(), 107) 'mon dd, yyyy';
SELECT convert(varchar, getdate(), 108) 'hh:mm:ss';
SELECT convert(varchar, getdate(), 109) 'mon dd yyyy hh:mm:ss:mmmAM (or PM)';
SELECT convert(varchar, getdate(), 110) 'mm-dd-yyyy';
SELECT convert(varchar, getdate(), 111) 'yyyy/mm/dd';
SELECT convert(varchar, getdate(), 112) 'yyyymmdd';
SELECT convert(varchar, getdate(), 113) 'dd mon yyyy hh:mm:ss:mmm';
SELECT convert(varchar, getdate(), 114) 'hh:mm:ss:mmm(24h)';
SELECT convert(varchar, getdate(), 120) 'yyyy-mm-dd hh:mm:ss(24h)';
SELECT convert(varchar, getdate(), 121) 'yyyy-mm-dd hh:mm:ss.mmm';
SELECT convert(varchar, getdate(), 126) 'yyyy-mm-ddThh:mm:ss.mmm';

-- 2.字串轉日期
SELECT convert(datetime, '2021-08-16 21:52:22', 120)　'yyyy-mm-dd hh:mm:ss(24h)';




-- MySQL
SELECT SYSDATE(), YEAR(SYSDATE()), MONTH(SYSDATE()), DAY(SYSDATE()),
HOUR(SYSDATE()), MINUTE(SYSDATE()), SECOND(SYSDATE());


-- MS SQL
SELECT GETDATE(), YEAR(GETDATE()), MONTH(GETDATE()), DAY(GETDATE());

SELECT GETDATE() 'Today',
DATEPART(year,GETDATE()) 'Year Part',
DATEPART(month,GETDATE()) 'Month Part',
DATEPART(day,GETDATE()) 'Day Part',
DATEPART(hour,GETDATE()) 'Hour Part',
DATEPART(minute,GETDATE()) 'Minute Part',
DATEPART(second,GETDATE()) 'Second Part',
DATEPART(millisecond,GETDATE()) 'MilliSecond Part';






